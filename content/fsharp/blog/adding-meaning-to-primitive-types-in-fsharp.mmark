---
title: "Adding Meaning to Primitive Types in Fsharp"
date: 2018-02-10T11:00:36+05:30
draft: true
tags : ["fsharp"]
---

One of the recommended guideline in Domain Driven Design is modelling the domain ideas 
using the domain type (CustomerName, CustomerId) instead of using their corressponding primitive type (string, int). 
In fsharp, with the help of [Single Case Discriminated Union](https://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/), we can follow this guideline with minimal effort. 

While following this practice in one of my recent project in fsharp, I came across an interesting use case and I used a lesser-known approach to solve the problem. 
In this blog post, I will be sharing the little-known approach that I employed to solve the use case.


## The Problem Domain

Let's assume that we are developing an F# Application for managing our perosonal expenses. 

One of the core domain idea that we'll use a lot is **Money**. 

In .NET, the primitive data type `decimal` is the appropriate for financial and monetary calculations. 

Hence to model **Money** in fsharp, what we need is a Single Case Discriminated Union type wrapping the `decimal` type.

```fsharp
type Money = Money of decimal
```

> To keep things simple, we are not going to consider currency and exchange rates


The next thing is modelling the income source and expense categories. For brevity, let's keep just two in each.

```fsharp
type IncomeSource =
| Salary
| Royalty

type ExpenseCategory =
| Food
| Entertainment
```

The final domain representation that we need is `Transaction`, which is either a `Credit` or a `Debit`. 

```fsharp
type Income = {
  Amount : Money
  Source : IncomeSource
} 

type Expense = {
  Amount : Money
  Category : ExpenseCategory
}

type Transaction =
| Credit of Income 
| Debit of Expense
```

For our tiny perosonal finance managing application, these domain models are just sufficient. So, let's dive into the use cases. 


### Use Case #1

Our first use case is finding the expenditure on a given `ExpenseCategory` from the list of transaction

```fsharp
ExpenseCategory -> Transaction list -> Money
```

To implement it, let's create an intermediate function `getExpenses`, that retrieves the expenses from a list of transaction.

```fsharp
// Transaction list -> Expense list
let rec getExpenses transactions =
  getExpenses' transactions []
and getExpenses' transactions expenses =
  match transactions with
  | [] -> expenses
  | x :: xs -> 
    match x with
    | Debit expense ->
      getExpenses' xs (expense :: expenses)
    | _ -> getExpenses' xs expenses
```

With the help of this `getExpenses` function, we can now implement the use case as follows

{callout="yes"}
```fsharp
// ExpenseCategory -> Transaction list -> Money
let getExpenditure expenseCategory transactions =
  getExpenses transactions
  |> List.filter (fun e -> e.Category = expenseCategory)
  |> List.sumBy (fun expense -> 
    let (Money m) = expense.Amount <1>
    m <2>
  )
  |> Money <3>
```

<1> We are unwrapping the underlying `decimal` value from the `Money` type. 

<2> Returing the unwrapped decimal value.

<3> Putting the decimal value back to `Money` type after computing the sum.


Now we have implementation for use case #1 and let's move to the next.

### Use Case #2

The second use case is computing the average expenditure on a given `ExpenseCategory` from the list of transactions

{callout="yes"}
```fsharp
// ExpenseCategory -> Transaction list list -> Money
let averageExpenditure expenseCategory transactionsList =
  transactionsList
  |> List.map (getExpenditure expenseCategory)
  |> List.map (fun (Money m) -> m) <1>
  |> List.average
  |> Money <2>
```

Like the use case #1,

<1> Unwraps the `decimal` value from the `Money` type and returns it.

<2> Put the result of the average function back to the `Money` type.


### Use Case #3

Our final use case is given a list of transaction, we have to compute the balance money. 

As we know, the formula for computing the balance is 

```plain
balance money = (sum of credited amount of money) - (sum of debited amount of money)
``` 
Applying the same in fsharp, we will end up with the following implementation

{callout="yes"}
```fsharp
// Transaction list -> Money
let balance transactions =
  transactions
  |> List.map ( function
                | Credit x -> 
                  let (Money m) = x.Amount <1>
                  m
                | Debit y ->
                  let (Money m) = y.Amount <2>
                  -m
              )
  |> List.sum
  |> Money <3>
```

In the `balance` function, we have used an optimized version of the formula. 

Instead of computing the sum of credits and debits separately, we are applying the unary minus to the all debits and computing the sum of these transformed values in a single go. 

Like what we did for the use cases #1 and #2, Here also we are unwrapping the `decimal` type from the `Money` type at <1> and <2>, and at <3> we are wrapping the `decimal` type back to `Money` type after computing the sum. 

## Unwrapping and Wrapping

Though we have a good domain model in the form of `Money`, a discouraging aspect is the repeatation of unwrapping and wrapping code to perform calculations on the `Money` type.  